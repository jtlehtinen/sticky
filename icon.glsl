// The image in the icon file was generated by this shadertoy.
// This is a pixel/fragment shader. Easiest way to edit is to
// copy&paste this code to [shadertoy](https://www.shadertoy.com/new)
// or with vscode shadertoy extension.

// Signed distance field functions from:
// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm

float sd_circle(vec2 point, float radius) {
  return length(point) - radius;
}

float sd_segment(vec2 point, vec2 from, vec2 to) {
  vec2 a = point - from;
  vec2 b = to - from;
  float h = clamp(dot(a, b) / dot(b, b), 0.0, 1.0);
  return length(a - b * h);
}

float sd_rounded_box(vec2 p, vec2 b, vec4 r) {
  r.xy = (p.x > 0.0) ? r.xy : r.zw;
  r.x  = (p.y > 0.0) ? r.x  : r.y;
  vec2 q = abs(p) - b + r.x;
  return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;
}

float sd_triangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {
  vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;
  vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;
  vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );
  vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );
  vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );
  float s = sign( e0.x*e2.y - e0.y*e2.x );
  vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),
                   vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),
                   vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));
  return -sqrt(d.x)*sign(d.y);
}

float intersect(float a, float b){
  return max(a, b);
}

float subtract(float a, float b) {
  return intersect(a, -b);
}

void mainImage(out vec4 out_color, in vec2 fragment_coords) {
  const float kpi = 3.14159265359;

  const vec3 color_primary = vec3(0.949, 0.902, 1);
  const vec3 color_secondary = vec3(0.569, 0.349, 0.78);

  vec2 uv = fragment_coords / iResolution.xy * 2.0 - 1.0;
  uv.x *= iResolution.x / iResolution.y;

  const float minute_arm_length = 0.78;

  vec4 color = vec4(0.0);

  float size = 0.9;

  {
    float dim = size/2.0;

    vec2 p = uv;
    float d = sd_rounded_box(p, vec2(size), vec4(0.2));

    p.x += size - dim;
    p.y -= size - dim;
    d = subtract(d, sd_triangle(p, vec2(-dim), vec2(-dim, dim), vec2(dim)));

    float opacity = smoothstep(0.0, 0.01, -d);
    color.xyz = mix(color.xyz, color_primary, opacity);
    color.a = max(color.a, opacity);
  }

  {
    float dim = size/2.0;
    vec2 p = uv;
    p.x += size - dim;
    p.y -= size - dim;
    float opacity = smoothstep(0.0, 0.005, -sd_triangle(p, vec2(-dim), vec2(dim, -dim), vec2(dim)));
    color.xyz = mix(color.xyz, color_secondary, opacity);
    color.a = max(color.a, opacity);
  }

  out_color = color;
}
